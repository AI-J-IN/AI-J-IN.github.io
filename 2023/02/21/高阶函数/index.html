<!DOCTYPE HTML>
<html lang="en">

<head>
    <!--Setting-->
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
    <meta http-equiv="Cache-Control" content="no-siteapp">
    <meta http-equiv="Cache-Control" content="no-transform">
    <meta name="renderer" content="webkit|ie-comp|ie-stand">
    <meta name="apple-mobile-web-app-capable" content="Hexo">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <meta name="format-detection" content="telephone=no,email=no,adress=no">
    <meta name="browsermode" content="application">
    <meta name="screen-orientation" content="portrait">
    <meta name="theme-version" content="1.3.0">
    <meta name="root" content="/">
    <link rel="dns-prefetch" href="http://example.com">
    <!--SEO-->

<meta name="keywords" content="高阶函数" />


<meta name="description" content="高阶函数变量可以指向函数1234print(abs(-10))10print(abs)&lt;built-in function abs&gt;

可以看到 abs(10)是函数调用，而abs是..." />


<meta name="robots" content="all" />
<meta name="google" content="all" />
<meta name="googlebot" content="all" />
<meta name="verify" content="all" />
    <!--Title-->

<title>
    
    高阶函数 |
    
    Hexo
</title>

<link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">


<link rel="icon" href="/favicon.ico">

    


<link rel="stylesheet" href="/css/bootstrap.min.css?rev=3.3.7.css">
<link rel="stylesheet" href="/css/font-awesome.min.css?rev=4.7.0.css">
<link rel="stylesheet" href="/css/style.css?rev=@@hash.css">

    
<div class="hide">
    <script type="text/javascript">
    var cnzz_protocol = (("https:" == document.location.protocol) ? " https://" : " http://");
    document.write(unescape("%3Cspan class='cnzz_stat_icon_1263868967 hide' %3E%3Cscript%20src%3D%22https%3A%2F%2Fs95.cnzz.com%2Fz_stat.php%3Fweb_id%3D1272564536%22%3E%3C%2Fscript%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "s19.cnzz.com/z_stat.php%3Fid%3D1263868967%26show%3Dpic1' type='text/javascript'%3E%3C/script%3E"));
    </script>
</div>




    

<meta name="generator" content="Hexo 6.3.0"></head>
<!--[if lte IE 8]>
<style>
    html{ font-size: 1em }
</style>
<![endif]-->
<!--[if lte IE 9]>
<div style="ie">你使用的浏览器版本过低，为了你更好的阅读体验，请更新浏览器的版本或者使用其他现代浏览器，比如Chrome、Firefox、Safari等。</div>
<![endif]-->
<body>
    <header class="main-header"  style="background-image:url(
    https://hexo-theme-snippet-1251680922.cos.ap-beijing.myqcloud.com/img/banner.jpg)"
     >
    <div class="main-header-box">
        <a class="header-avatar" href="/" title='John Doe'>
            <img src="/img/avatar.jpg" alt="logo头像" class="img-responsive center-block">
        </a>
        <div class="branding">
            <!--<h2 class="text-hide">Snippet主题,从未如此简单有趣</h2>-->
            
            <img src="/img/branding.png" alt="Snippet 博客主题" class="img-responsive center-block">
            
        </div>
    </div>
</header>
    <nav class="main-navigation">
    <div class="container">
        <div class="row">
            <div class="col-sm-12">
                <div class="navbar-header"><span class="nav-toggle-button collapsed pull-right" data-toggle="collapse" data-target="#main-menu" id="mnav">
                        <span class="sr-only"></span>
                        <i class="fa fa-bars"></i>
                    </span>
                    <a class="navbar-brand" href="http://example.com">
                        Hexo</a>
                </div>
                <div class="collapse navbar-collapse" id="main-menu">
                    <ul class="menu">
                        
                        <li role="presentation" class="text-center">
                            <a href="/"><i class="fa "></i>
                                Home</a>
                        </li>
                        
                        <li role="presentation" class="text-center">
                            <a href="/categories/编程语言/"><i class="fa "></i>
                                编程语言</a>
                        </li>
                        
                        <li role="presentation" class="text-center">
                            <a href="/categories/数学/"><i class="fa "></i>
                                数学</a>
                        </li>
                        
                        <li role="presentation" class="text-center">
                            <a href="/categories/机器学习/"><i class="fa "></i>
                                机器学习</a>
                        </li>
                        
                        <li role="presentation" class="text-center">
                            <a href="/categories/深度学习/"><i class="fa "></i>
                                深度学习</a>
                        </li>
                        
                        <li role="presentation" class="text-center">
                            <a href="/archives/"><i class="fa "></i>
                                时间轴</a>
                        </li>
                        
                    </ul>
                </div>
            </div>
        </div>
    </div>
</nav>
    <section class="content-wrap">
        <div class="container">
            <div class="row">
                <main class="col-md-8 main-content m-post">
                    <p id="process"></p>
<article class="post">
    <div class="post-head">
        <h1 id="高阶函数">
            
            高阶函数
            
        </h1>
        <div class="post-meta">
    
    <span class="categories-meta fa-wrap">
        <i class="fa fa-folder-open-o"></i>
        <a class="category-link" href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/">编程语言</a>
    </span>
    
    
    <span class="fa-wrap">
        <i class="fa fa-tags"></i>
        <span class="tags-meta">
            
            <a class="tag-none-link" href="/tags/%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0/" rel="tag">高阶函数</a>
            
        </span>
    </span>
    
    
    
    <span class="fa-wrap">
        <i class="fa fa-clock-o"></i>
        <span class="date-meta">
            2023/02/21</span>
    </span>
    
    
</div>
        
        
    </div>
    
    <div class="post-body post-content">
        <h2 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h2><h3 id="变量可以指向函数"><a href="#变量可以指向函数" class="headerlink" title="变量可以指向函数"></a>变量可以指向函数</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">print(abs(-10))</span><br><span class="line">10</span><br><span class="line">print(abs)</span><br><span class="line">&lt;built-in function abs&gt;</span><br></pre></td></tr></table></figure>

<p>可以看到 abs(10)是函数调用，而abs是函数本身</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">b=abs(-10)</span><br><span class="line">print(b)</span><br><span class="line">10</span><br><span class="line"></span><br><span class="line">c=abs</span><br><span class="line">print(c)</span><br><span class="line">&lt;built-in function abs&gt;</span><br></pre></td></tr></table></figure>

<p>函数本身也可以赋值给变量，即 变量指向函数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">d=abs</span><br><span class="line">print(d(-10))</span><br><span class="line">10</span><br></pre></td></tr></table></figure>

<p>说明变量<code>d</code>现在已经指向了<code>abs</code>函数本身。直接调用<code>abs()</code>函数和调用变量<code>d()</code>完全相同</p>
<h3 id="函数名也是变量"><a href="#函数名也是变量" class="headerlink" title="函数名也是变量"></a>函数名也是变量</h3><p>​	函数名其实就是指向函数的变量！对于<code>abs()</code>这个函数，完全可以把函数名<code>abs</code>看成变量，它指向一个可以计算绝对值的函数！</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">abs = 10</span><br><span class="line">print(abs(-10))</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">TypeError: &#x27;int&#x27; object is not callable</span><br></pre></td></tr></table></figure>

<p>​	把<code>abs</code>指向<code>10</code>后，就无法通过<code>abs(-10)</code>调用该函数了！因为<code>abs</code>这个变量已经不指向求绝对值函数而是指向一个整数<code>10</code>！</p>
<p>当然实际代码绝对不能这么写，这里是为了说明函数名也是变量。要恢复<code>abs</code>函数，请重启Python交互环境。</p>
<h3 id="传入函数"><a href="#传入函数" class="headerlink" title="传入函数"></a>传入函数</h3><p>​	既然变量可以指向函数，函数的参数能接收变量，那么一个函数就可以接收另一个函数作为参数，这种函数就称之为**<u>高阶函数</u>**	</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">def add(x, y, f):</span><br><span class="line">    return f(x) + f(y)</span><br><span class="line">    </span><br><span class="line">当我们调用add(-5, 6, abs)时，参数x，y和f分别接收-5，6和abs，根据函数定义，我们可以推导计算过程为</span><br><span class="line">x = -5</span><br><span class="line">y = 6</span><br><span class="line">f = abs</span><br><span class="line">print(add(x,y,f))</span><br><span class="line">11</span><br><span class="line"></span><br><span class="line">f(x) + f(y) ==&gt; abs(-5) + abs(6) ==&gt; 11</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="map-x2F-reduce"><a href="#map-x2F-reduce" class="headerlink" title="map&#x2F;reduce"></a>map&#x2F;reduce</h3><h4 id="map"><a href="#map" class="headerlink" title="map"></a>map</h4><p>​	<code>map()</code>函数接收两个参数，一个是函数，一个是<code>Iterable</code>，<code>map</code>将传入的函数依次作用到序列的每个元素，并把结果作为新的<code>Iterator</code>返回。</p>
<p>​	比如我们有一个函数f(x)&#x3D;x2，要把这个函数作用在一个list <code>[1, 2, 3, 4, 5, 6, 7, 8, 9]</code>上，就可以用<code>map()</code>实现如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">def f(x):</span><br><span class="line">    return  x*x</span><br><span class="line"></span><br><span class="line">r=map(f,[1,2,3,4,5,6,7])</span><br><span class="line">print(list(r))</span><br><span class="line"></span><br><span class="line">[1, 4, 9, 16, 25, 36, 49]</span><br></pre></td></tr></table></figure>

<p>​	<code>map()</code>传入的第一个参数是<code>f</code>，即函数对象本身。由于结果<code>r</code>是一个<code>Iterator</code>，<code>Iterator</code>是惰性序列，因此通过<code>list()</code>函数让它把整个序列都计算出来并返回一个list。</p>
<p>​	<code>map()</code>作为高阶函数，事实上它把运算规则抽象了，因此，我们不但可以计算简单的f(x)&#x3D;x2，还可以计算任意复杂的函数，比如，把这个list所有数字转为字符串：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">r=map(str,[1,2,3,4,5,6,7])</span><br><span class="line">print(list(r))</span><br><span class="line"></span><br><span class="line">[&#x27;1&#x27;, &#x27;2&#x27;, &#x27;3&#x27;, &#x27;4&#x27;, &#x27;5&#x27;, &#x27;6&#x27;, &#x27;7&#x27;]</span><br></pre></td></tr></table></figure>



<h4 id="reduce"><a href="#reduce" class="headerlink" title="reduce"></a>reduce</h4><p>​	<code>reduce</code>把一个函数作用在一个序列<code>[x1, x2, x3, ...]</code>上，这个函数必须接收两个参数，<code>reduce</code>把结果继续和序列的下一个元素做累积计算</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">from functools import reduce</span><br><span class="line"></span><br><span class="line">def add(x,y):</span><br><span class="line">    return x+y</span><br><span class="line"></span><br><span class="line">print(reduce(add,[1,3,5,7,9]))</span><br></pre></td></tr></table></figure>

<p>​	当然求和运算可以直接用Python内建函数<code>sum()</code>，没必要动用<code>reduce</code>。</p>
<p>但是如果要把序列<code>[1, 3, 5, 7, 9]</code>变换成整数<code>13579</code>，<code>reduce</code>就可以派上用场：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">def fn(x,y):</span><br><span class="line">    return x*10+y</span><br><span class="line"></span><br><span class="line">print(reduce(fn,[1,3,5,7,9]))</span><br></pre></td></tr></table></figure>

<p>​	如果考虑到字符串<code>str</code>也是一个序列，对上面的例子稍加改动，配合<code>map()</code>，我们就可以写出把<code>str</code>转换为<code>int</code>的函数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">from functools import reduce</span><br><span class="line"></span><br><span class="line">DIGITS = &#123;&#x27;0&#x27;: 0, &#x27;1&#x27;: 1, &#x27;2&#x27;: 2, &#x27;3&#x27;: 3, &#x27;4&#x27;: 4, &#x27;5&#x27;: 5, &#x27;6&#x27;: 6, &#x27;7&#x27;: 7, &#x27;8&#x27;: 8, &#x27;9&#x27;: 9&#125;</span><br><span class="line"></span><br><span class="line">def str2int(s):</span><br><span class="line">    def fn(x, y):</span><br><span class="line">        return x * 10 + y</span><br><span class="line">    def char2num(s):</span><br><span class="line">        return DIGITS[s]</span><br><span class="line">    return reduce(fn, map(char2num, s))</span><br></pre></td></tr></table></figure>



<h3 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h3><p>​	<code>filter()</code>函数用于过滤序列，<code>filter()</code>也接收一个函数和一个序列。和<code>map()</code>不同的是，<code>filter()</code>把传入的函数依次作用于每个元素，然后根据返回值是<code>True</code>还是<code>False</code>决定保留还是丢弃该元素。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">def is_odd(n):</span><br><span class="line">    return n%2==1</span><br><span class="line"></span><br><span class="line">print(list(filter(is_odd,[1,2,4,5,6,9,10,15])))</span><br><span class="line"></span><br><span class="line">[1, 5, 9, 15]</span><br></pre></td></tr></table></figure>

<p>​	把一个序列中的空字符串删掉</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">def not_emoty(s):</span><br><span class="line">    return s and   s.strip()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">print(list(filter(not_emoty,[&#x27;A&#x27;,&#x27;&#x27;,&#x27;B&#x27;,None,&#x27;C&#x27;,&#x27;&#x27;])))</span><br><span class="line">[&#x27;A&#x27;, &#x27;B&#x27;, &#x27;C&#x27;]</span><br></pre></td></tr></table></figure>

<p>​	strip()方法，方法用于移除字符串头尾指定的字符（默认为空格或换行符）或字符序列。</p>
<p>​	注意：该方法只能删除开头或是结尾的字符，不能删除中间部分的字符。</p>
<p>注意到<code>filter()</code>函数返回的是一个<code>Iterator</code>，也就是一个惰性序列，所以要强迫<code>filter()</code>完成计算结果，需要用<code>list()</code>函数获得所有结果并返回list。</p>
<h4 id="用filter求素数"><a href="#用filter求素数" class="headerlink" title="用filter求素数"></a>用filter求素数</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">计算素数的一个方法是埃氏筛法，它的算法理解起来非常简单：</span><br><span class="line"></span><br><span class="line">首先，列出从2开始的所有自然数，构造一个序列：</span><br><span class="line"></span><br><span class="line">2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, ...</span><br><span class="line"></span><br><span class="line">取序列的第一个数2，它一定是素数，然后用2把序列的2的倍数筛掉：</span><br><span class="line"></span><br><span class="line">3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, ...</span><br><span class="line"></span><br><span class="line">取新序列的第一个数3，它一定是素数，然后用3把序列的3的倍数筛掉：</span><br><span class="line"></span><br><span class="line">5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, ...</span><br><span class="line"></span><br><span class="line">取新序列的第一个数5，然后用5把序列的5的倍数筛掉：</span><br><span class="line"></span><br><span class="line">7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, ...</span><br><span class="line"></span><br><span class="line">不断筛下去，就可以得到所有的素数。</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>​	用Python来实现这个算法，可以先构造一个从3开始的奇数序列：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">def _odd_iter():</span><br><span class="line">    n = 1</span><br><span class="line">    while True:</span><br><span class="line">        n = n + 2</span><br><span class="line">        yield n</span><br></pre></td></tr></table></figure>

<p>​	注意这是一个生成器，并且是一个无限序列，所以不要执行</p>
<p>​	然后定义一个筛选函数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">def _not_divisible(n):</span><br><span class="line">    return lambda x: x % n &gt; 0</span><br></pre></td></tr></table></figure>

<p>​	定义一个生成器，不断返回下一个素数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">def primes():</span><br><span class="line">    yield 2</span><br><span class="line">    it = _odd_iter() # 初始序列</span><br><span class="line">    while True:</span><br><span class="line">        n = next(it) # 返回序列的第一个数</span><br><span class="line">        yield n</span><br><span class="line">        it = filter(_not_divisible(n), it) # 构造新序列</span><br></pre></td></tr></table></figure>

<p>​	这个生成器先返回第一个素数<code>2</code>，然后，利用<code>filter()</code>不断产生筛选后的新的序列。</p>
<p>由于<code>primes()</code>也是一个无限序列，所以调用时需要设置一个退出循环的条件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 打印1000以内的素数:</span><br><span class="line">for n in primes():</span><br><span class="line">    if n &lt; 1000:</span><br><span class="line">        print(n)</span><br><span class="line">    else:</span><br><span class="line">        break</span><br></pre></td></tr></table></figure>

<p>注意到<code>Iterator</code>是惰性计算的序列，所以我们可以用Python表示“全体自然数”，“全体素数”这样的序列，而代码非常简洁</p>
<h3 id="sorted（排序算法）"><a href="#sorted（排序算法）" class="headerlink" title="sorted（排序算法）"></a>sorted（排序算法）</h3><p>​	排序也是在程序中经常用到的算法。无论使用冒泡排序还是快速排序，排序的核心是比较两个元素的大小。如果是数字，我们可以直接比较，但如果是字符串或者两个dict呢？直接比较数学上的大小是没有意义的，因此，比较的过程必须通过函数抽象出来</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">print(sorted([36, 5, -12, 9, -21]))</span><br><span class="line">[-21, -12, 5, 9, 36]</span><br></pre></td></tr></table></figure>

<p>​	<code>	sorted()</code>函数也是一个高阶函数，它还可以接收一个<code>key</code>函数来实现自定义的排序，例如按绝对值大小排序：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">print(sorted([36, 5, -12, 9, -21], key=abs)) </span><br><span class="line">[5, 9, -12, -21, 36]</span><br></pre></td></tr></table></figure>

<p>​	key指定的函数将作用于list的每一个元素上，并根据key函数返回的结果进行排序。对比原始的list和经过<code>key=abs</code>处理过的list</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">list = [36, 5, -12, 9, -21]</span><br><span class="line"></span><br><span class="line">keys = [36, 5,  12, 9,  21]</span><br></pre></td></tr></table></figure>



<p>字符串排序</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">print(sorted([&#x27;bob&#x27;, &#x27;about&#x27;, &#x27;Zoo&#x27;, &#x27;Credit&#x27;])) </span><br><span class="line">[&#x27;Credit&#x27;, &#x27;Zoo&#x27;, &#x27;about&#x27;, &#x27;bob&#x27;]</span><br></pre></td></tr></table></figure>

<p>​	默认情况下，对字符串排序，是按照ASCII的大小比较的，由于<code>&#39;Z&#39; &lt; &#39;a&#39;</code>，结果，大写字母<code>Z</code>会排在小写字母<code>a</code>的前面</p>
<p>​	现在，我们提出排序应该忽略大小写，按照字母序排序。要实现这个算法，不必对现有代码大加改动，只要我们能用一个key函数把字符串映射为忽略大小写排序即可。忽略大小写来比较两个字符串，实际上就是先把字符串都变成大写（或者都变成小写），再比较。</p>
<p>这样，我们给<code>sorted</code>传入key函数，即可实现忽略大小写的排序：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">print(sorted([&#x27;bob&#x27;, &#x27;about&#x27;, &#x27;Zoo&#x27;, &#x27;Credit&#x27;], key=str.lower)) </span><br><span class="line">[&#x27;about&#x27;, &#x27;bob&#x27;, &#x27;Credit&#x27;, &#x27;Zoo&#x27;]</span><br></pre></td></tr></table></figure>

<p>​	</p>
<p>​	要进行反向排序，不必改动key函数，可以传入第三个参数<code>reverse=True</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">print(sorted([&#x27;bob&#x27;, &#x27;about&#x27;, &#x27;Zoo&#x27;, &#x27;Credit&#x27;], key=str.lower, reverse=True))</span><br><span class="line">[&#x27;Zoo&#x27;, &#x27;Credit&#x27;, &#x27;bob&#x27;, &#x27;about&#x27;]</span><br></pre></td></tr></table></figure>



<h3 id="返回函数"><a href="#返回函数" class="headerlink" title="返回函数"></a>返回函数</h3><p>​	高阶函数除了可以接受函数作为参数外，还可以把函数作为结果值返回</p>
<p>​	我们来实现一个可变参数的求和。通常情况下，求和的函数是这样定义的</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">def calc_sum(*args):</span><br><span class="line">    ax = 0</span><br><span class="line">    for n in args:</span><br><span class="line">        ax = ax + n</span><br><span class="line">    return ax</span><br></pre></td></tr></table></figure>

<p>​	但是，如果不需要立刻求和，而是在后面的代码中，根据需要再计算怎么办？可以不返回求和的结果，而是返回求和的函数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">def lazy_sum(*args):</span><br><span class="line">    def sum():</span><br><span class="line">        ax = 0</span><br><span class="line">        for n in args:</span><br><span class="line">            ax = ax + n</span><br><span class="line">        return ax</span><br><span class="line">    return sum</span><br></pre></td></tr></table></figure>

<p>​	当我们调用<code>lazy_sum()</code>时，返回的并不是求和结果，而是求和函数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">f = lazy_sum(1, 3, 5, 7, 9)</span><br><span class="line">print(f)</span><br><span class="line">&lt;function lazy_sum.&lt;locals&gt;.sum at 0x101c6ed90&gt;</span><br></pre></td></tr></table></figure>

<p>​	调用函数<code>f</code>时，才真正计算求和的结果</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">print(f())</span><br><span class="line">25</span><br></pre></td></tr></table></figure>



<p>​	在这个例子中，我们在函数<code>lazy_sum</code>中又定义了函数<code>sum</code>，并且，内部函数<code>sum</code>可以引用外部函数<code>lazy_sum</code>的参数和局部变量，当<code>lazy_sum</code>返回函数<code>sum</code>时，相关参数和变量都保存在返回的函数中，这种称为“闭包（Closure）”的程序结构拥有极大的威力</p>
<p>​	请再注意一点，当我们调用<code>lazy_sum()</code>时，每次调用都会返回一个新的函数，即使传入相同的参数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">f1 = lazy_sum(1, 3, 5, 7, 9)</span><br><span class="line">f2 = lazy_sum(1, 3, 5, 7, 9)</span><br><span class="line">f1==f2</span><br><span class="line"></span><br><span class="line">False</span><br></pre></td></tr></table></figure>

<p>​	<code>f1()</code>和<code>f2()</code>的调用结果互不影响</p>
<h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><p>​	注意到返回的函数在其定义内部引用了局部变量<code>args</code>，所以，当一个函数返回了一个函数后，其内部的局部变量还被新函数引用，所以，闭包用起来简单，实现起来可不容易。</p>
<p>另一个需要注意的问题是，返回的函数并没有立刻执行，而是直到调用了<code>f()</code>才执行。我们来看一个例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">def count():</span><br><span class="line">    fs=[]</span><br><span class="line">    for i in range(1,4):</span><br><span class="line">        def f():</span><br><span class="line">            return i*i</span><br><span class="line">        fs.append(f)</span><br><span class="line">    return  fs</span><br><span class="line"></span><br><span class="line">f1,f2,f3=count()</span><br><span class="line">print(f1(),f2(),f3())</span><br><span class="line"></span><br><span class="line">9 9 9</span><br></pre></td></tr></table></figure>

<p>​	在上面的例子中，每次循环，都创建了一个新的函数，然后，把创建的3个函数都返回了。</p>
<p>你可能认为调用<code>f1()</code>，<code>f2()</code>和<code>f3()</code>结果应该是<code>1</code>，<code>4</code>，<code>9</code>，但实际结果是9 9 9 </p>
<p>​	原因就在于返回的函数引用了变量<code>i</code>，但它并非立刻执行。等到3个函数都返回时，它们所引用的变量<code>i</code>已经变成了<code>3</code>，因此最终结果为<code>9</code>。</p>
<h4 id="返回闭包时牢记一点：返回函数不要引用任何循环变量，或者后续会发生变化的变量"><a href="#返回闭包时牢记一点：返回函数不要引用任何循环变量，或者后续会发生变化的变量" class="headerlink" title="返回闭包时牢记一点：返回函数不要引用任何循环变量，或者后续会发生变化的变量"></a>返回闭包时牢记一点：返回函数不要引用任何循环变量，或者后续会发生变化的变量</h4><p>​	如果一定要引用循环变量怎么办？方法是再创建一个函数，用该函数的参数绑定循环变量当前的值，无论该循环变量后续如何更改，已绑定到函数参数的值不变：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">def count():</span><br><span class="line">    def f(j):</span><br><span class="line">        def g():</span><br><span class="line">            return j*j</span><br><span class="line">        return g</span><br><span class="line">    fs = []</span><br><span class="line">    for i in range(1, 4):</span><br><span class="line">        fs.append(f(i)) # f(i)立刻被执行，因此i的当前值被传入f()</span><br><span class="line">    return fs</span><br><span class="line">    </span><br><span class="line"> f1, f2, f3 = count()</span><br><span class="line"> print(f1(),f2(),f3())</span><br><span class="line"></span><br><span class="line">1 4 9 </span><br></pre></td></tr></table></figure>

<p>​	缺点是代码较长，可利用lambda函数缩短代码</p>
<h3 id="nonlocal"><a href="#nonlocal" class="headerlink" title="nonlocal"></a>nonlocal</h3><p>​	使用闭包，就是内层函数引用了外层函数的局部变量。如果只是读外层变量的值，我们会发现返回的闭包函数调用一切正常</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">def inc():</span><br><span class="line">    x = 0</span><br><span class="line">    def fn():</span><br><span class="line">        # 仅读取x的值:</span><br><span class="line">        return x + 1</span><br><span class="line">    return fn</span><br><span class="line"></span><br><span class="line">f = inc()</span><br><span class="line">print(f()) # 1</span><br><span class="line">print(f()) # 1</span><br></pre></td></tr></table></figure>

<p>​	但是，如果对外层变量赋值，由于Python解释器会把<code>x</code>当作函数<code>fn()</code>的局部变量，它会报错</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">def inc():</span><br><span class="line">    x = 0</span><br><span class="line">    def fn():</span><br><span class="line">        # nonlocal x</span><br><span class="line">        x = x + 1</span><br><span class="line">        return x</span><br><span class="line">    return fn</span><br><span class="line"></span><br><span class="line">f = inc()</span><br><span class="line">print(f()) # 1</span><br><span class="line">print(f()) # 2</span><br></pre></td></tr></table></figure>

<p>​	原因是<code>x</code>作为局部变量并没有初始化，直接计算<code>x+1</code>是不行的。但我们其实是想引用<code>inc()</code>函数内部的<code>x</code>，所以需要在<code>fn()</code>函数内部加一个<code>nonlocal x</code>的声明。加上这个声明后，解释器把<code>fn()</code>的<code>x</code>看作外层函数的局部变量，它已经被初始化了，可以正确计算<code>x+1</code></p>
<h4 id="使用闭包时，对外层变量赋值前，需要先使用nonlocal声明该变量不是当前函数的局部变量。"><a href="#使用闭包时，对外层变量赋值前，需要先使用nonlocal声明该变量不是当前函数的局部变量。" class="headerlink" title="使用闭包时，对外层变量赋值前，需要先使用nonlocal声明该变量不是当前函数的局部变量。"></a>使用闭包时，对外层变量赋值前，需要先使用nonlocal声明该变量不是当前函数的局部变量。</h4>
    </div>
    
    <div class="post-footer">
        <div>
            
            转载声明：
            商业转载请联系作者获得授权,非商业转载请注明出处 © <a href="" target="_blank">Snippet</a>
            
            
        </div>
        <div>
            
        </div>
    </div>
</article>
<div class="article-nav prev-next-wrap clearfix">
    
    
    <a href="/2023/02/20/%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/" class="next-post btn btn-default" title='高级特性'>
        <span class="hidden-lg">下一篇</span>
        <span class="hidden-xs">
            高级特性</span><i class="fa fa-angle-right fa-fw"></i>
    </a>
    
</div>

<div id="comments">
    
    
<div class="utteranc">
  
  <script
    src='https://utteranc.es/client.js'
    repo='shenliyang/snippet-comment'
    issue-term='pathname'
    issue-number=''
    theme='github-light'
    label=''
    crossorigin='anonymous'
    async
  ></script>
</div>



</div>

                </main>
                
                    <aside id="article-toc" role="navigation" class="col-md-4">
    <div class="widget">
        <h3 class="title">
            Table of Contents
        </h3>
        
        <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0"><span class="toc-text">高阶函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%98%E9%87%8F%E5%8F%AF%E4%BB%A5%E6%8C%87%E5%90%91%E5%87%BD%E6%95%B0"><span class="toc-text">变量可以指向函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%90%8D%E4%B9%9F%E6%98%AF%E5%8F%98%E9%87%8F"><span class="toc-text">函数名也是变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%A0%E5%85%A5%E5%87%BD%E6%95%B0"><span class="toc-text">传入函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#map-x2F-reduce"><span class="toc-text">map&#x2F;reduce</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#map"><span class="toc-text">map</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#reduce"><span class="toc-text">reduce</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#filter"><span class="toc-text">filter</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%94%A8filter%E6%B1%82%E7%B4%A0%E6%95%B0"><span class="toc-text">用filter求素数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#sorted%EF%BC%88%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%EF%BC%89"><span class="toc-text">sorted（排序算法）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%94%E5%9B%9E%E5%87%BD%E6%95%B0"><span class="toc-text">返回函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%97%AD%E5%8C%85"><span class="toc-text">闭包</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%94%E5%9B%9E%E9%97%AD%E5%8C%85%E6%97%B6%E7%89%A2%E8%AE%B0%E4%B8%80%E7%82%B9%EF%BC%9A%E8%BF%94%E5%9B%9E%E5%87%BD%E6%95%B0%E4%B8%8D%E8%A6%81%E5%BC%95%E7%94%A8%E4%BB%BB%E4%BD%95%E5%BE%AA%E7%8E%AF%E5%8F%98%E9%87%8F%EF%BC%8C%E6%88%96%E8%80%85%E5%90%8E%E7%BB%AD%E4%BC%9A%E5%8F%91%E7%94%9F%E5%8F%98%E5%8C%96%E7%9A%84%E5%8F%98%E9%87%8F"><span class="toc-text">返回闭包时牢记一点：返回函数不要引用任何循环变量，或者后续会发生变化的变量</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#nonlocal"><span class="toc-text">nonlocal</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E9%97%AD%E5%8C%85%E6%97%B6%EF%BC%8C%E5%AF%B9%E5%A4%96%E5%B1%82%E5%8F%98%E9%87%8F%E8%B5%8B%E5%80%BC%E5%89%8D%EF%BC%8C%E9%9C%80%E8%A6%81%E5%85%88%E4%BD%BF%E7%94%A8nonlocal%E5%A3%B0%E6%98%8E%E8%AF%A5%E5%8F%98%E9%87%8F%E4%B8%8D%E6%98%AF%E5%BD%93%E5%89%8D%E5%87%BD%E6%95%B0%E7%9A%84%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E3%80%82"><span class="toc-text">使用闭包时，对外层变量赋值前，需要先使用nonlocal声明该变量不是当前函数的局部变量。</span></a></li></ol></li></ol></li></ol>
        
    </div>
</aside>
                
            </div>
        </div>
    </section>
    <footer class="main-footer">
    <div class="container">
        <div class="row">
        </div>
    </div>
</footer>
<a id="back-to-top" class="icon-btn hide">
    <i class="fa fa-chevron-up"></i>
</a>
    <div class="copyright">
    <div class="container">
        <div class="row">
            <div class="col-sm-12">
                <div class="busuanzi">
    
</div>
            </div>
            <div class="col-sm-12">
                <span>Copyright &copy;
                    2017
                    
                </span> |
                <span>
                    Powered by <a href="//hexo.io" class="copyright-links" target="_blank" rel="nofollow">Hexo</a>
                </span> |
                <span>
                    Theme by <a href="//github.com/shenliyang/hexo-theme-snippet.git" class="copyright-links" target="_blank" rel="nofollow">Snippet</a>
                </span>
            </div>
        </div>
    </div>
</div>




<script src="/js/app.js?rev=@@hash.js"></script>

</body>
</html>