<!DOCTYPE HTML>
<html lang="en">

<head>
    <!--Setting-->
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
    <meta http-equiv="Cache-Control" content="no-siteapp">
    <meta http-equiv="Cache-Control" content="no-transform">
    <meta name="renderer" content="webkit|ie-comp|ie-stand">
    <meta name="apple-mobile-web-app-capable" content="Hexo">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <meta name="format-detection" content="telephone=no,email=no,adress=no">
    <meta name="browsermode" content="application">
    <meta name="screen-orientation" content="portrait">
    <meta name="theme-version" content="1.3.0">
    <meta name="root" content="/">
    <link rel="dns-prefetch" href="http://example.com">
    <!--SEO-->

<meta name="keywords" content="四大基石" />


<meta name="description" content="Flink_四大基石（Checkpoint、State、Time、Window）基本概念窗口 Window
​	流计算中一般在对流数据进行操作之前都会&#x3D;&#x3D;先进行开窗&#x3D..." />


<meta name="robots" content="all" />
<meta name="google" content="all" />
<meta name="googlebot" content="all" />
<meta name="verify" content="all" />
    <!--Title-->

<title>
    
    Flink_四大基石 |
    
    Hexo
</title>

<link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">


<link rel="icon" href="/favicon.ico">

    


<link rel="stylesheet" href="/css/bootstrap.min.css?rev=3.3.7.css">
<link rel="stylesheet" href="/css/font-awesome.min.css?rev=4.7.0.css">
<link rel="stylesheet" href="/css/style.css?rev=@@hash.css">

    
<div class="hide">
    <script type="text/javascript">
    var cnzz_protocol = (("https:" == document.location.protocol) ? " https://" : " http://");
    document.write(unescape("%3Cspan class='cnzz_stat_icon_1263868967 hide' %3E%3Cscript%20src%3D%22https%3A%2F%2Fs95.cnzz.com%2Fz_stat.php%3Fweb_id%3D1272564536%22%3E%3C%2Fscript%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "s19.cnzz.com/z_stat.php%3Fid%3D1263868967%26show%3Dpic1' type='text/javascript'%3E%3C/script%3E"));
    </script>
</div>




    

<meta name="generator" content="Hexo 6.3.0"></head>
<!--[if lte IE 8]>
<style>
    html{ font-size: 1em }
</style>
<![endif]-->
<!--[if lte IE 9]>
<div style="ie">你使用的浏览器版本过低，为了你更好的阅读体验，请更新浏览器的版本或者使用其他现代浏览器，比如Chrome、Firefox、Safari等。</div>
<![endif]-->
<body>
    <header class="main-header"  style="background-image:url(
    https://hexo-theme-snippet-1251680922.cos.ap-beijing.myqcloud.com/img/banner.jpg)"
     >
    <div class="main-header-box">
        <a class="header-avatar" href="/" title='John Doe'>
            <img src="/img/avatar.jpg" alt="logo头像" class="img-responsive center-block">
        </a>
        <div class="branding">
            <!--<h2 class="text-hide">Snippet主题,从未如此简单有趣</h2>-->
            
            <img src="/img/branding.png" alt="Snippet 博客主题" class="img-responsive center-block">
            
        </div>
    </div>
</header>
    <nav class="main-navigation">
    <div class="container">
        <div class="row">
            <div class="col-sm-12">
                <div class="navbar-header"><span class="nav-toggle-button collapsed pull-right" data-toggle="collapse" data-target="#main-menu" id="mnav">
                        <span class="sr-only"></span>
                        <i class="fa fa-bars"></i>
                    </span>
                    <a class="navbar-brand" href="http://example.com">
                        Hexo</a>
                </div>
                <div class="collapse navbar-collapse" id="main-menu">
                    <ul class="menu">
                        
                        <li role="presentation" class="text-center">
                            <a href="/"><i class="fa "></i>
                                Home</a>
                        </li>
                        
                        <li role="presentation" class="text-center">
                            <a href="/categories/编程语言/"><i class="fa "></i>
                                编程语言</a>
                        </li>
                        
                        <li role="presentation" class="text-center">
                            <a href="/categories/数学/"><i class="fa "></i>
                                数学</a>
                        </li>
                        
                        <li role="presentation" class="text-center">
                            <a href="/categories/机器学习/"><i class="fa "></i>
                                机器学习</a>
                        </li>
                        
                        <li role="presentation" class="text-center">
                            <a href="/categories/深度学习/"><i class="fa "></i>
                                深度学习</a>
                        </li>
                        
                        <li role="presentation" class="text-center">
                            <a href="/categories/离线/"><i class="fa "></i>
                                离线</a>
                        </li>
                        
                        <li role="presentation" class="text-center">
                            <a href="/categories/实时/"><i class="fa "></i>
                                实时</a>
                        </li>
                        
                        <li role="presentation" class="text-center">
                            <a href="/archives/"><i class="fa "></i>
                                时间轴</a>
                        </li>
                        
                    </ul>
                </div>
            </div>
        </div>
    </div>
</nav>
    <section class="content-wrap">
        <div class="container">
            <div class="row">
                <main class="col-md-8 main-content m-post">
                    <p id="process"></p>
<article class="post">
    <div class="post-head">
        <h1 id="Flink_四大基石">
            
            Flink_四大基石
            
        </h1>
        <div class="post-meta">
    
    <span class="categories-meta fa-wrap">
        <i class="fa fa-folder-open-o"></i>
        <a class="category-link" href="/categories/%E5%AE%9E%E6%97%B6/">实时</a>
    </span>
    
    
    <span class="fa-wrap">
        <i class="fa fa-tags"></i>
        <span class="tags-meta">
            
            <a class="tag-none-link" href="/tags/%E5%9B%9B%E5%A4%A7%E5%9F%BA%E7%9F%B3/" rel="tag">四大基石</a>
            
        </span>
    </span>
    
    
    
    <span class="fa-wrap">
        <i class="fa fa-clock-o"></i>
        <span class="date-meta">
            2023/02/26</span>
    </span>
    
    
</div>
        
        
    </div>
    
    <div class="post-body post-content">
        <h1 id="Flink-四大基石（Checkpoint、State、Time、Window）"><a href="#Flink-四大基石（Checkpoint、State、Time、Window）" class="headerlink" title="Flink_四大基石（Checkpoint、State、Time、Window）"></a>Flink_四大基石（Checkpoint、State、Time、Window）</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="窗口-Window"><a href="#窗口-Window" class="headerlink" title="窗口 Window"></a>窗口 Window</h3><ul>
<li>​	流计算中一般在对流数据进行操作之前都会&#x3D;&#x3D;先进行开窗&#x3D;&#x3D;，即基于一个什么样的窗口上做这个计算</li>
<li>​	Flink提供了&#x3D;&#x3D;开箱即用的各种窗口&#x3D;&#x3D;，比如滑动窗口、滚动窗口、会话窗口以及非常灵活的自定义的窗口</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://nightlies.apache.org/flink/flink-docs-release-1.13/docs/dev/datastream/operators/windows/"></a></p>
<h3 id="时间-Time"><a href="#时间-Time" class="headerlink" title="时间 Time"></a>时间 Time</h3><ul>
<li>Flink中窗口计算，基本上都是&#x3D;&#x3D;基于时间设置窗口&#x3D;&#x3D;</li>
<li>Flink还实现了Watermark的机制，能够支持基于事件时间的处理，能够容忍<strong>迟到&#x2F;乱序</strong>的数据</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://nightlies.apache.org/flink/flink-docs-release-1.13/docs/concepts/time/"></a></p>
<h3 id="状态-State"><a href="#状态-State" class="headerlink" title="状态 State"></a>状态 State</h3><ul>
<li>​	Flink计算引擎，自身就是&#x3D;&#x3D;基于状态计算框架&#x3D;&#x3D;，默认情况下程序自己管理状态</li>
<li>​	提供&#x3D;&#x3D;一致性的语义&#x3D;&#x3D;，使得用户在编程时能够更轻松、更容易地去管理状态</li>
<li>​	提供一套非常&#x3D;&#x3D;简单明了的State API&#x3D;&#x3D;，包括ValueState、ListState、MapState，BroadcastState</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://nightlies.apache.org/flink/flink-docs-release-1.13/docs/concepts/stateful-stream-processing/"></a></p>
<h3 id="检查点-Checkpoint"><a href="#检查点-Checkpoint" class="headerlink" title="检查点 Checkpoint"></a>检查点 Checkpoint</h3><ul>
<li>Flink Checkpoint检查点：&#x3D;&#x3D;保存状态数据&#x3D;&#x3D;</li>
<li>基于Chandy-Lamport算法实现了一个&#x3D;&#x3D;分布式的一致性的快照&#x3D;&#x3D;，从而提供了一致性的语义</li>
<li>进行Checkpoint后，可以设置&#x3D;&#x3D;自动进行故障恢复&#x3D;&#x3D;</li>
<li>保存点Savepoint，人工进行Checkpoint操作，进行程序恢复执行</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://nightlies.apache.org/flink/flink-docs-release-1.13/docs/dev/datastream/fault-tolerance/checkpointing/"></a></p>
<h2 id="Flink-Window"><a href="#Flink-Window" class="headerlink" title="Flink Window"></a>Flink Window</h2><p>​	窗口（window）就是从 Streaming 到 Batch 的一个桥梁&#96;。窗口将无界流（unbounded data stream）划分很多有界流（bounded stream），对无界流进行计算：批处理Batch Processing。</p>
<p><img src="/2023/02/26/Flink-%E5%9B%9B%E5%A4%A7%E5%9F%BA%E7%9F%B3/1.png"></p>
<p>​	</p>
<p>​	在实际业务需求中，往往说窗口，指的就是&#x3D;&#x3D;基于时间Time窗口&#x3D;&#x3D;，比如最近1分钟内数据，指的就是1分钟时间内产生的数据，放在窗口中。</p>
<p><img src="/2023/02/26/Flink-%E5%9B%9B%E5%A4%A7%E5%9F%BA%E7%9F%B3/2.png"></p>
<h3 id="Flink-Window-窗口的结构"><a href="#Flink-Window-窗口的结构" class="headerlink" title="Flink Window 窗口的结构"></a>Flink Window 窗口的结构</h3><ul>
<li>第一、<strong>窗口分配器（WindowAssigner）</strong>：将数据流中的元素分配到对应的窗口。</li>
<li>第二、<strong>窗口函数（Window Function）</strong>：当满足窗口触发条件后，对窗口内的数据使用窗口处理函数（Window Function）进行处理，常用的有reduce、aggregate、process。</li>
<li>其他的<strong>trigger</strong>、<strong>evictor</strong>则是窗口的触发和销毁过程中的附加选项，主要面向需要更多自定义的高级编程者，如果不设置则会使用默认的配置。</li>
</ul>
<p><img src="/2023/02/26/Flink-%E5%9B%9B%E5%A4%A7%E5%9F%BA%E7%9F%B3/3.png"></p>
<p>​	</p>
<p>​	上图是<strong>窗口的生命周期示意图</strong>，假如设置的是<strong>一个10分钟的滚动窗口</strong>，第一个窗口的起始时间是0:00，结束时间是0:10，后面以此类推。当数据流中的元素流入后，窗口分配器会根据时间（Event Time或Processing Time）分配给相应的窗口。相应窗口满足了触发条件，比如已经到了窗口的结束时间，会触发相应的Window Function进行计算。</p>
<p>​	从数据类型上来看，1个DataStream经过<strong>keyBy</strong>转换成KeyedStream，再经过<strong>window</strong>转换成WindowedStream，要在之上进行<strong>reduce、aggregate或process</strong>等Window Function，对数据进行必要的聚合操作。</p>
<p><img src="/2023/02/26/Flink-%E5%9B%9B%E5%A4%A7%E5%9F%BA%E7%9F%B3/4.png"></p>
<h3 id="Flink-Window之Window-类型"><a href="#Flink-Window之Window-类型" class="headerlink" title="Flink Window之Window 类型"></a>Flink Window之Window 类型</h3><p><img src="/2023/02/26/Flink-%E5%9B%9B%E5%A4%A7%E5%9F%BA%E7%9F%B3/Snipaste_2023-02-24_22-44-48.png"></p>
<blockquote>
<ul>
<li>1）、时间窗口<code>TimeWindow</code><ul>
<li>按照时间间隔划分出窗口，并对窗口中数据进行计</li>
<li>分为：滚动（Tumbling）窗口和滑动（Sliding）窗口</li>
</ul>
</li>
<li>2）、计数窗口<code>CountWindow</code><ul>
<li>按照<code>数据条目数</code>进行设置窗口，比如每10条数据统计一次</li>
<li>分为：滚动窗口和滑动窗口</li>
</ul>
</li>
<li>3）、会话窗口<code>SessionWindow</code><ul>
<li>会话Session相关，表示多久没有来数据，比如5分钟都没有来数据，将前面的数据作为一个窗口</li>
<li>当登录某个网站，超过一定时间对网站网页未进行任何操作（比如30分钟），自动退出登录，需要用户重新登录，Session会话超时</li>
</ul>
</li>
</ul>
</blockquote>
<p><img src="/2023/02/26/Flink-%E5%9B%9B%E5%A4%A7%E5%9F%BA%E7%9F%B3/Snipaste_2023-02-24_22-49-03.png"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># 1、滚动窗口（翻滚窗口或者固定窗口）</span><br><span class="line">	基于时间滚动窗口</span><br><span class="line">	基于计数滚动窗口</span><br><span class="line">	</span><br><span class="line"># 2、滑动窗口</span><br><span class="line">	基于滑动窗口</span><br><span class="line">	基于计数滑动窗口</span><br><span class="line">	</span><br><span class="line"># 3、会话窗口</span><br><span class="line">	基于时间，设置超时时间间隔</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<blockquote>
<p>1）、&#x3D;&#x3D;time-window（时间窗口）&#x3D;&#x3D;</p>
<ul>
<li>根据<code>时间划分</code>窗口，如每xx分钟统计，最近xx分钟的数据</li>
<li><a href>实时分析：趋势分析</a></li>
</ul>
</blockquote>
<blockquote>
<p>2）、&#x3D;&#x3D;count-window（计数窗口）&#x3D;&#x3D;：</p>
<ul>
<li>根据<code>数量划分</code>窗口，如每xx个数据统计，最近xx个数据</li>
<li>[此种方式窗口计算，在实际项目中使用不多，但是有些特殊业务需要，需要使用此场景。](</li>
</ul>
</blockquote>
<p><img src="/2023/02/26/Flink-%E5%9B%9B%E5%A4%A7%E5%9F%BA%E7%9F%B3/Snipaste_2023-02-24_22-53-41.png"></p>
<p>在Flink窗口计算中，无论时间窗口还是计数窗口，都可以分为2种类型：<code>滚动Tumbling和滑动Sliding窗口</code></p>
<p>​											[窗口有两个重要的属性: 窗口<code>大小size</code>和滑动<code>间隔slide</code>](</p>
<p>滚动窗口（Tumbling Window）</p>
<p>​	条件：**窗口大小size  &#x3D;   滑动间隔 slide</p>
<p><img src="/2023/02/26/Flink-%E5%9B%9B%E5%A4%A7%E5%9F%BA%E7%9F%B3/Snipaste_2023-02-24_22-56-37.png"></p>
<p>滑动窗口（Sliding Window）</p>
<ul>
<li>条件：<strong>窗口大小 !&#x3D; 滑动间隔</strong>，通常条件【<code>窗口大小size &gt; 滑动间隔slide</code>】</li>
</ul>
<p><img src="/2023/02/26/Flink-%E5%9B%9B%E5%A4%A7%E5%9F%BA%E7%9F%B3/Snipaste_2023-02-24_22-57-11.png"></p>
<p>上面图中展示的以计数窗口CountWindow讲解滚动窗口和滑动窗口，下图为以时间窗口为例讲解</p>
<p><img src="/2023/02/26/Flink-%E5%9B%9B%E5%A4%A7%E5%9F%BA%E7%9F%B3/Snipaste_2023-02-24_22-58-37.png"></p>
<p> &#x3D;&#x3D;session窗口&#x3D;&#x3D;跟滚动窗口和滑动窗口相比，不会有重叠和固定的开始时间和结束时间的情况，相反，<strong>当它在一个固定的时间周期内不再收到元素，即非活动间隔产生，那个这个窗口就会关闭</strong>。</p>
<p><img src="/2023/02/26/Flink-%E5%9B%9B%E5%A4%A7%E5%9F%BA%E7%9F%B3/Snipaste_2023-02-24_22-59-42.png"></p>
<p>一个session窗口通过一个session间隔来配置，这个session间隔定义了非活跃周期的长度，当这个非活跃周期产生，那么当前的session将关闭并且后续的元素将被分配到新的session窗口中去。</p>
<p><img src="/2023/02/26/Flink-%E5%9B%9B%E5%A4%A7%E5%9F%BA%E7%9F%B3/Snipaste_2023-02-24_23-01-30.png"></p>
<p>会话窗口，基于时间设置间隔Gap，产出窗口，对窗口中数据进行计算。</p>
<h2 id="Flink-Time"><a href="#Flink-Time" class="headerlink" title="Flink Time"></a>Flink Time</h2><p>​	在Flink 流式处理中，会涉及到时间的不同概念，如下图所示</p>
<p><img src="/2023/02/26/Flink-%E5%9B%9B%E5%A4%A7%E5%9F%BA%E7%9F%B3/Snipaste_2023-02-25_09-59-22.png"></p>
<ul>
<li><p>1）、事件时间<code>EventTime</code></p>
<ul>
<li>事件真真正正发生产生的时间，比如订单数据中订单时间表示订单产生的时间</li>
</ul>
</li>
<li><p>2）、摄入时间<code>IngestionTime</code></p>
<ul>
<li>数据被流式程序获取的时间</li>
</ul>
</li>
<li><p>3）、处理时间<code>ProcessingTime</code></p>
<ul>
<li>事件真正被处理&#x2F;计算的时间</li>
</ul>
</li>
</ul>
<p>以上的三个时间，实际业务计算时更加关注哪一个？</p>
<p>答案是： EventTime（因为：事件时间更能反应事件本质，只要事件时间一产生就不会变化）</p>
<p>通过几个示例，感受对数据处理时，需要使用基于<strong>事件时间EventTime</strong>进行分析，更加合理化</p>
<p><img src="/2023/02/26/Flink-%E5%9B%9B%E5%A4%A7%E5%9F%BA%E7%9F%B3/Snipaste_2023-02-25_10-04-07.png"></p>
<p><img src="/2023/02/26/Flink-%E5%9B%9B%E5%A4%A7%E5%9F%BA%E7%9F%B3/Snipaste_2023-02-25_10-04-23.png"></p>
<p><img src="/2023/02/26/Flink-%E5%9B%9B%E5%A4%A7%E5%9F%BA%E7%9F%B3/Snipaste_2023-02-25_10-04-53.png"></p>
<p><img src="/2023/02/26/Flink-%E5%9B%9B%E5%A4%A7%E5%9F%BA%E7%9F%B3/Snipaste_2023-02-25_10-05-34.png"></p>
<blockquote>
<p>所以在实际项目中，Flink流计算中窗口计算，往往就是 <a href>基于事件时间EventTime Window窗口分析。</a></p>
</blockquote>
<p>​					[所以Flink 1.12版本开始，基于时间time窗口Window分析，默认时间语义：EventTime事件时间。](</p>
<p>​	</p>
<p>​	此外，Flink 框架新版本中，Time时间语义仅仅支持：**事件时间EventTime和处理时间ProcessingTime</p>
<h2 id="乱序数据处理之Watermark"><a href="#乱序数据处理之Watermark" class="headerlink" title="乱序数据处理之Watermark"></a>乱序数据处理之Watermark</h2><p>​	基于&#x3D;&#x3D;事件时间EventTime窗口&#x3D;&#x3D;分析，默认情况下，如果某个窗口触发计算以后，再来一条窗口内的数据，此时不会计算这条数据，而是直接丢弃。</p>
<p><img src="/2023/02/26/Flink-%E5%9B%9B%E5%A4%A7%E5%9F%BA%E7%9F%B3/Snipaste_2023-02-25_10-22-42.png"></p>
<p>​	流处理从事件产生，到流经 source，再到 operator，中间是有一个过程和时间的，虽然大部分情况下，流到 operator 的数据都是按照事件产生的时间顺序来的，但是也不排除由于网络、背压等原因，导致乱序的产生，&#x3D;&#x3D;所谓乱序，就是指 Flink 接收到的事件的先后顺序不是严格按照事件的 Event Time 顺序排列的&#x3D;&#x3D;，所以 Flink 最初设计的时候，就考虑到了网络延迟，网络乱序等问题，所以提出了一个抽象概念：<code>水印（WaterMark）</code>；</p>
<p><img src="/2023/02/26/Flink-%E5%9B%9B%E5%A4%A7%E5%9F%BA%E7%9F%B3/Snipaste_2023-02-25_10-23-20.png"></p>
<p>​	在实际业务数据中，数据乱序到达流处理程序，属于正常现象，原因在于<strong>网络延迟导致数据延迟，无法避免的</strong>，所以应该可以<a href>允许数据延迟达到（在某个时间范围内），依然参与窗口计算</a>。</p>
<p>​				比如允许数据最大乱序延迟时间为2秒，那么此时只要符合时间范围乱序数据都会处理，此种机制：<strong>Watermark水印机制</strong>。</p>
<p>[水印机制Watermark：允许数据乱序到达，在对应窗口中进行计算（延迟时间很短）](</p>
<h3 id="Watermark水位线定义"><a href="#Watermark水位线定义" class="headerlink" title="Watermark水位线定义"></a>Watermark水位线定义</h3><p>​	Watermark 就是 给数据再额外的加一个时间列，也就是 Watermark 是个 时间戳！</p>
<p>查看Watermark源码，可以看到其中有一个属性：timestamp时间戳</p>
<p><img src="/2023/02/26/Flink-%E5%9B%9B%E5%A4%A7%E5%9F%BA%E7%9F%B3/Snipaste_2023-02-25_10-49-28.png"></p>
<h4 id="Watermaek-如何计算"><a href="#Watermaek-如何计算" class="headerlink" title="Watermaek 如何计算"></a>Watermaek 如何计算</h4><p>Watermark &#x3D; 数据的事件事件 - 最大允许的延迟时间或乱序时间</p>
<p>针对窗口计算时，Watermark值计算，参考整个窗口中数据计算</p>
<p><img src="/2023/02/26/Flink-%E5%9B%9B%E5%A4%A7%E5%9F%BA%E7%9F%B3/Snipaste_2023-02-25_13-22-42.png"></p>
<p>Watermark是用来触发窗口计算的！</p>
<p>窗口计算的触发条件是：</p>
<ol>
<li>窗口中有数据</li>
<li>Watermark &gt;&#x3D; 窗口的结束时间</li>
</ol>
<p>当设置水位Watermark以后，窗口触发计算和乱序数据达到处理流程</p>
<p><img src="/2023/02/26/Flink-%E5%9B%9B%E5%A4%A7%E5%9F%BA%E7%9F%B3/Snipaste_2023-02-25_13-54-17.png"></p>
<p>​	基于事件时间窗口统计，往往存在数据乱序达到（由于网络延迟原因），所以设置watermark水印机制，允许数据短时间内延迟达到，依然进行处理数据。</p>
<h2 id="延迟数据处理之Allowed-Lateness"><a href="#延迟数据处理之Allowed-Lateness" class="headerlink" title="延迟数据处理之Allowed Lateness"></a>延迟数据处理之Allowed Lateness</h2><p><a href>默认情况下，当watermark通过end-of-window之后，再有之前的数据到达时，这些数据会被删除。</a>为了避免有些迟到的数据被删除，因此产生了<strong>allowedLateness</strong>的概念。</p>
<ul>
<li>简单来讲，allowedLateness就是针对event time而言，对于watermark超过end-of-window之后，还<a href>允许有一段时间（也是以event time来衡量）来等待之前的数据到达，以便再次处理这些数据</a>。</li>
<li>默认情况下，如果不指定allowedLateness，其值是0，即对于watermark超过end-of-window之后，还有此window的数据到达时，这些数据被删除掉了。</li>
</ul>
<blockquote>
<p>​		<code>延迟数据</code>是指：在当前窗口【假设窗口范围为10-15】已经计算之后，又来了一个属于该窗口的数据【假设事件时间为13】，这时候仍<code>会触发window操作</code>，这种数据就称为延迟数据。</p>
</blockquote>
<p>​		</p>
<p>​		Allowed Lateness 机制允许用户<strong>设置一个允许的最大迟到时⻓</strong>。Flink 会在窗口关闭后一直保存窗口的状态直至超过允许迟到时⻓，这期间的迟到事件不会被丢弃，而是默认会触发窗口重新计算<strong>。因为保存窗口状态需要额外内存</strong>，并且如果窗口计算使用了ProcessWindowFunction， API 还可能使得每个迟到事件触发一次窗口的全量计算，<strong>代价比较大，所以允许迟到时⻓不宜设得太⻓，迟到事件也不宜过多</strong>，否则应该考虑降低水位线提高的速度或者调整算法。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote>
<p><a href>针对基于事件时间EventTime窗口分析，如何解决<code>乱序数据</code>和<code>延迟数据</code>的呢？？？</a></p>
</blockquote>
<ul>
<li><strong>1）、乱序数据：Watermark</strong><ul>
<li>使用水位线Watermark，给每条数据加上一个时间戳</li>
<li>Watermark &#x3D; 数据事件时间 - 最大允许乱序时间</li>
<li>当数据的Watermark &gt;&#x3D; 窗口结束时间，并且窗口内有数据，触发窗口数据计算</li>
</ul>
</li>
<li><strong>2）、延迟数据：AllowedLateness</strong><ul>
<li>设置方法参数：<code>allowedLateness</code>，表示允许延迟数据最多可以迟到多久，还可以进行计算（保存窗口，并且触发窗口计算）</li>
<li><a href>当某个窗口触发计算以后，继续等待多长时间，如果在等待时间范围内，有数据达到时，依然会触发窗口计算。如果到达等待时长以后，没有数据达到，销毁窗口数据信息。</a></li>
</ul>
</li>
</ul>
<h2 id="延迟数据处理之Side-Output"><a href="#延迟数据处理之Side-Output" class="headerlink" title="延迟数据处理之Side Output"></a>延迟数据处理之Side Output</h2><p>​	此外，如果延迟数据超过设置<code>allowedLateness</code>时长到达，可以通过<strong>侧边流Side OutputTag保存延迟数据</strong>，然后进行单独处理</p>
<p>​	如下所示：基于事件时间窗口分析，数据乱序（watermark）、数据延迟（Allowedness）和非常延迟（SideOutput）处理方案示意图。	</p>
<p><img src="/2023/02/26/Flink-%E5%9B%9B%E5%A4%A7%E5%9F%BA%E7%9F%B3/Snipaste_2023-02-25_14-56-53.png"></p>
<blockquote>
<p>用<code>AllowedLateness</code> 与 <code>SideOutputLateData</code>处理迟到数据</p>
</blockquote>
<ul>
<li><strong>AllowedLateness</strong>: 窗口销毁前，迟到数据，会继续触发窗口计算。<ul>
<li>Globle Window, 此值默认Long.MAX_VALUE,即窗口永远不会结束；</li>
<li>其他窗口，此值默认0，即直接丢弃，不再触发窗口计算。</li>
</ul>
</li>
<li><strong>SideOutputLateData</strong>: 窗口销毁后，依然迟到的数据，可单独收集起来。<ul>
<li>默认无。</li>
<li>如当AllowedLateness设置为0，即可通过SideOutputLateData将所有迟到数据都收集起来，另做处理。</li>
</ul>
</li>
</ul>
<p><code>状态State</code>和检查点<code>Checkpoint</code>、端到端精确性一次语义（&#x3D;&#x3D;EOS&#x3D;&#x3D;）。</p>
<p>​	Flink 流式计算引擎，属于<strong>状态计算框架</strong>，在程序运行时，<a href>管理状态和基于状态计算</a>。对程序状态State进行快照和保存：<strong>Checkpoint（程序自动执行）</strong>和<strong>SavePoint（人为手动执行）</strong>。</p>
<p><img src="/2023/02/26/Flink-%E5%9B%9B%E5%A4%A7%E5%9F%BA%E7%9F%B3/Snipaste_2023-02-25_22-24-42.png"></p>
<h2 id="状态State"><a href="#状态State" class="headerlink" title="状态State"></a>状态State</h2><p>​		在Flink架构体系中，有状态计算可以说是Flink非常重要的特征之一。[有状态计算是指在程序计算过程中，在Flink程序内部，存储计算产生的中间结果，并提供给Functions 或 算子计算使用。]</p>
<p><img src="/2023/02/26/Flink-%E5%9B%9B%E5%A4%A7%E5%9F%BA%E7%9F%B3/Snipaste_2023-02-26_21-48-50.png"></p>
<p>词频统计WordCount程序，其中<strong>词频就是使用State状态进行存储</strong>，&#x3D;&#x3D;每个Key对应一个词频（状态）&#x3D;&#x3D;。</p>
<p><img src="/2023/02/26/Flink-%E5%9B%9B%E5%A4%A7%E5%9F%BA%E7%9F%B3/Snipaste_2023-02-26_21-50-26.png"></p>
<p>​	为什么Flink知道之前已经处理过一次 hadoop和world，这就是 <code>state</code>发挥作用了，这里是&#x3D;&#x3D;被称为 keyed state 存储了之前需要统计的数据&#x3D;&#x3D;，所以Flink 程序知道 hello和 world词频。</p>
<h3 id="Flink-State-状态"><a href="#Flink-State-状态" class="headerlink" title="Flink State 状态"></a>Flink State 状态</h3><p>​	Apache Flink作为一个计算框架，Flink提供了有状态的计算，封装了一些底层的实现，比如状态的高效存储、Checkpoint和Savepoint持久化备份机制、计算资源扩缩容等问题。因为Flink接管了这些问题，开发者只需调用Flink API，这样可以更加专注于业务逻辑。</p>
<h4 id="Flink-State之状态及存储结构"><a href="#Flink-State之状态及存储结构" class="headerlink" title="Flink State之状态及存储结构"></a>Flink State之状态及存储结构</h4><p>​	什么是状态&#x3D;&#x3D;：流式计算的数据往往是转瞬即逝， 真实业务场景不可能说所有的数据都是进来之后就走掉，没有任何东西留下来，那么<strong>留下来的东西其实就是称之为state</strong>，中文可以翻译成<strong>状态</strong>。</p>
<p><img src="/2023/02/26/Flink-%E5%9B%9B%E5%A4%A7%E5%9F%BA%E7%9F%B3/Snipaste_2023-02-26_21-53-42.png"></p>
<p>​	在上面这个图中，所有的原始数据进入用户代码之后再输出到下游，&#x3D;&#x3D;如果中间涉及到 state 的读写，这些状态会存储在本地的 state backend（可以对标成嵌入式本地 kv 存储）当中&#x3D;&#x3D;。</p>
<p>​	在Flink中，可以这样理解State：某task&#x2F;operator在某时刻的一个中间结果。</p>
<p><img src="/2023/02/26/Flink-%E5%9B%9B%E5%A4%A7%E5%9F%BA%E7%9F%B3/Snipaste_2023-02-26_21-54-31.png"></p>
<blockquote>
<p>为什么流式计算中需要State状态呢？</p>
</blockquote>
<ol>
<li>与批计算相比，&#x3D;&#x3D;State是流计算特有的&#x3D;&#x3D;，批计算没有failover机制，要么成功，要么重新计算。</li>
<li>流计算在大多数场景下是&#x3D;&#x3D;增量计算，数据逐条处理（大多数场景），每次计算是在上一次计算结果之上进行处理的&#x3D;&#x3D;，这样的机制势必要<a href>将上一次的计算结果进行存储（生产模式要持久化）</a>；</li>
<li>另外由于机器、网络、脏数据等原因导致的程序错误，在&#x3D;&#x3D;重启job时候需要从成功的检查点(checkpoint)进行state的恢复&#x3D;&#x3D;。增量计算，Failover这些机制都需要state的支撑。</li>
</ol>
<blockquote>
<p>状态State存储在哪里呢？</p>
</blockquote>
<p>​			状态数据可以维系在<a href>本地存储</a>中，这里的存储可以是 <a href>Flink 的堆内存或者堆外内存</a>，也可以借助第三方的存储介质，例如：Flink中已经实现的RocksDB，当然用户也可以自己实现相应的缓存系统去存储状态信息，以完成更加复杂的计算逻辑。</p>
<p>​	状态计算其实就是需要&#x3D;&#x3D;考虑历史数据&#x3D;&#x3D;，而历史数据需要搞个地方存储起来。Flink为了方便不同分类的State的存储和管理，提供以下保存State的数据结构。</p>
<p><img src="/2023/02/26/Flink-%E5%9B%9B%E5%A4%A7%E5%9F%BA%E7%9F%B3/Snipaste_2023-02-26_21-57-14.png"></p>
<ul>
<li><p><code>ValueState&lt;T&gt;</code>：类型为T的<a href>单值</a>状态</p>
<ul>
<li>保存一个可以更新和检索的值（每个值都对应到当前的输入数据的key，因此算子接收到的每个key都可能对应一个值）。</li>
<li>这个值可以通过**update(T)<strong>进行更新，通过</strong>T value()**进行检索。</li>
</ul>
</li>
<li><p><code>ListState&lt;T&gt;</code>：key上的状态值为一个<a href>列表</a></p>
<ul>
<li>保存一个元素的列表，可以往这个列表中追加数据，并在当前的列表上进行检索。</li>
<li>可以通过**add(T)<strong>或者</strong>addAll(List<T>)<strong>进行添加元素，通过</strong>Iterable<T> get()**获得整个列表。</T></T></li>
<li>还可以通过**update(List<T>)**覆盖当前的列表。</T></li>
<li>如统计按用户id统计用户经常登录的IP</li>
</ul>
</li>
<li><p><code>MapState&lt;UK,UV&gt;</code>：即状态值为一个<a href>map</a></p>
<ul>
<li>维护了一个映射列表，可以添加键值对到状态中，也可以获得反映当前所有映射的迭代器。</li>
<li>使用**put(UK，UV)<strong>或者</strong>putAll(Map&lt;UK，UV&gt;)**添加映射。</li>
<li>使用**get(UK)**检索特定key。</li>
<li>使用**entries()，keys()和values()**分别检索映射、键和值的可迭代视图</li>
</ul>
</li>
<li><p><code>ReducingState&lt;T&gt;</code>：</p>
<ul>
<li>保存一个单值，表示添加到状态的所有值的聚合。</li>
<li>这种状态通过用户传入的<strong>reduceFunction</strong>，每次调用<strong>add</strong>方法添加值的时候，会调用<strong>reduceFunction</strong>，最后合并到一个单一的状态值。</li>
<li><code>AggregatingState&lt;IN,OUT&gt;</code>：保留一个单值，表示添加到状态的所有值的聚合。和ReducingState相反的是，聚合类型可能与添加到状态的元素的类型不同。</li>
<li><code>FoldingState&lt;T,ACC&gt;</code>：保留一个单值，表示添加到状态的所有值的聚合。与ReducingState相反，聚合类型可能与添加到状态的元素类型不同。</li>
</ul>
</li>
<li><p><code>Broadcast State</code>：具有Broadcast流的特殊属性</p>
<ul>
<li>类比批处理中广播变量：<strong>将小表数据广播到TaskManager内存，被Slot中运行Task任务使用</strong></li>
<li>一种小数据状态广播向其它流的形式，从而避免大数据流量的传输；</li>
<li>在这里，其它流是对广播状态只有只读操作的允许，因为不同任务间没有跨任务的信息交流。</li>
<li>一旦有运行实例对于广播状态数据进行更新了，就会造成状态不一致现象。</li>
</ul>
</li>
</ul>
<h3 id="Flink-State之状态分类"><a href="#Flink-State之状态分类" class="headerlink" title="Flink State之状态分类"></a>Flink State之状态分类</h3><p>​	在Flink中，按照基本类型，对State划分为两类：：&#x3D;&#x3D;Keyed State 和 Operator State</p>
<p><img src="/2023/02/26/Flink-%E5%9B%9B%E5%A4%A7%E5%9F%BA%E7%9F%B3/Snipaste_2023-02-26_22-00-47.png"></p>
<p><img src="/2023/02/26/Flink-%E5%9B%9B%E5%A4%A7%E5%9F%BA%E7%9F%B3/Snipaste_2023-02-26_22-01-16.png"></p>
<p>​	State状态中：OperatorState算子状态属于每个实例存储1个Stage值，但是KeyedState键控状态属于每个Key存储1个状态值</p>
<p><img src="/2023/02/26/Flink-%E5%9B%9B%E5%A4%A7%E5%9F%BA%E7%9F%B3/Snipaste_2023-02-26_22-03-01.png"></p>
<h4 id="Keyed-State-：键控状态"><a href="#Keyed-State-：键控状态" class="headerlink" title="Keyed State]()：键控状态"></a>Keyed State]()：键控状态</h4><ul>
<li>和Key有关的状态类型，KeyedStream流上的&#x3D;&#x3D;每一个key，都对应一个state&#x3D;&#x3D;；</li>
<li>只能应用于 KeyedStream 的函数与操作中；</li>
<li>存储数据结构：<strong>ValueState、ListState、MapState、ReducingState和AggregatingState</strong>等等</li>
</ul>
<p><img src="/2023/02/26/Flink-%E5%9B%9B%E5%A4%A7%E5%9F%BA%E7%9F%B3/Snipaste_2023-02-26_22-03-53.png"></p>
<p>​	基于KeyedStream上的状态，是跟特定的key绑定的，对KeyedStream流上的每一个key，都对应一个state**。</p>
<h4 id="Operator-State：算子状态"><a href="#Operator-State：算子状态" class="headerlink" title="Operator State：算子状态"></a><a href>Operator State</a>：算子状态</h4><ul>
<li>又称为 non-keyed state，每一个 operator state 都仅与一个 operator 的实例（1个SubTask任务）绑定；</li>
<li>可以用在所有算子上，每个算子子任务或者说每个算子实例共享一个状态，流入这个算子子任务的数据可以访问和更新这个状态。</li>
<li>常见的 operator state 是 数据源&#x3D;&#x3D;source state&#x3D;&#x3D;，例如记录当前 source 的 offset；</li>
<li>存储数据结构：<strong>ListState或BroadcastState</strong>等等</li>
</ul>
<p><img src="/2023/02/26/Flink-%E5%9B%9B%E5%A4%A7%E5%9F%BA%E7%9F%B3/Snipaste_2023-02-26_22-06-19.png"></p>
<p>​	Operator State又称为non-keyed state，与Key无关的State，每1个operator state都仅与1个operator的实例绑定。</p>
<h4 id="两种不同类型状态：-x3D-x3D-Keyed-State与Operator-State-x3D-x3D-，比较如下"><a href="#两种不同类型状态：-x3D-x3D-Keyed-State与Operator-State-x3D-x3D-，比较如下" class="headerlink" title="两种不同类型状态：&#x3D;&#x3D;Keyed State与Operator State&#x3D;&#x3D;，比较如下"></a>两种不同类型状态：&#x3D;&#x3D;Keyed State与Operator State&#x3D;&#x3D;，比较如下</h4><p><img src="/2023/02/26/Flink-%E5%9B%9B%E5%A4%A7%E5%9F%BA%E7%9F%B3/Snipaste_2023-02-26_22-07-25.png"></p>
<ul>
<li>Flink 为<strong>每个 key 维护一个状态实例</strong>，并将具有相同键的所有数据，都分区到同一个算子任务中，这个任务会维护和处理这个 key 对应的状态；</li>
<li>当任务处理一条数据时，它会自动将状态的访问范围限定为当前数据的 key。</li>
</ul>
<p><img src="/2023/02/26/Flink-%E5%9B%9B%E5%A4%A7%E5%9F%BA%E7%9F%B3/Snipaste_2023-02-26_22-09-23.png"></p>
<p>OperatorState** 状态针对<strong>非分组</strong>数据流DataStream状态管理，&#x3D;&#x3D;常常应用于数据源Source&#x3D;&#x3D;。</p>
<ul>
<li>算子状态的作用范围限定为&#x3D;&#x3D;算子任务&#x3D;&#x3D;，由同一并行任务所处理的所有数据都可以访问到相同的状态；</li>
<li>Kafka Connectors连接器中，提供的从Kafka消费数据：<code>FlinkKafkaConsumer</code>，实现自己管理状态：OperatorState，使用数据结构为<code>ListState</code>（列表存储状态）。</li>
</ul>
<p><img src="/2023/02/26/Flink-%E5%9B%9B%E5%A4%A7%E5%9F%BA%E7%9F%B3/Snipaste_2023-02-26_22-10-47.png"></p>
<h2 id="Flink-Checkpoint-检查点"><a href="#Flink-Checkpoint-检查点" class="headerlink" title="Flink Checkpoint 检查点"></a>Flink Checkpoint 检查点</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># RDD Checkpoint：</span><br><span class="line">	将RDD数据保存到可靠文件系统，比如HDFS</span><br><span class="line"></span><br><span class="line"># Flink Checkpoint：</span><br><span class="line">	将数据（状态State）保存到可靠文件系统，比如HDFS</span><br><span class="line">		状态数据：某一时刻状态快照</span><br></pre></td></tr></table></figure>

<p>​	什么是Checkpoint？也就是所谓的&#x3D;&#x3D;检查点&#x3D;&#x3D;，是&#x3D;&#x3D;用来故障恢复的一种机制&#x3D;&#x3D;。Spark也有Checkpoint，Flink与Spark一样，都是<strong>用Checkpoint来存储某一时间或者某一段时间的快照（snapshot），用于将任务恢复到指定的状态。</strong></p>
<p><img src="/2023/02/26/Flink-%E5%9B%9B%E5%A4%A7%E5%9F%BA%E7%9F%B3/Snipaste_2023-02-26_22-13-54.png"></p>
<p>状态State与检查点Checkpoint之间关系：<code>Checkpoint将某个时刻应用状态State进行快照Snapshot并保存Save</code>。</p>
<p>1）、<code>State</code>：存储的是某一个Operator的运行的状态&#x2F;历史值，是<strong>维护在内存Memory</strong>中。</p>
<p><img src="/2023/02/26/Flink-%E5%9B%9B%E5%A4%A7%E5%9F%BA%E7%9F%B3/Snipaste_2023-02-26_22-16-52.png"></p>
<p>2）、<code>Checkpoint</code>：某一时刻，Flink中所有Operator当前<strong>State的全局快照</strong>，一般存在<strong>磁盘上</strong>。</p>
<p><img src="/2023/02/26/Flink-%E5%9B%9B%E5%A4%A7%E5%9F%BA%E7%9F%B3/Snipaste_2023-02-26_22-17-11.png"></p>
<blockquote>
<p>Flink的Checkpoint的核心算法叫做<code>Chandy-Lamport</code>，是一种分布式快照（Distributed Snapshot）算法，应用到流式系统中就是<strong>确定一个 Global 的 Snapshot</strong>，错误处理的时候各个节点根据上一次的 Global Snapshot 来恢复。</p>
</blockquote>
<p>​											Chandy-Lamport 算法：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/53482103">https://zhuanlan.zhihu.com/p/53482103</a></p>
<h3 id="Flink-Checkpoint之执行流程"><a href="#Flink-Checkpoint之执行流程" class="headerlink" title="Flink Checkpoint之执行流程"></a>Flink Checkpoint之执行流程</h3><p>​	Checkpoint是Flink实现容错机制最核心的功能，它能够根据配置<a href>周期性地基于Stream中各个Operator&#x2F;task的状态State来生成快照，从而将这些状态数据定期持久化存储下来，当Flink程序一旦意外崩溃时，重新运行程序时可以有选择地从这些快照进行恢复，从而修正因为故障带来的程序数据异常</a>。</p>
<p>​	Checkpoint实现的核心就是<code>barrier（栅栏或屏障）</code>，Flink通过在数据集上<strong>间隔性</strong>的生成<strong>屏障barrier</strong>，并通过barrier将某段时间内的状态State数据保存到Checkpoint中（先快照，再保存）。</p>
<p><img src="/2023/02/26/Flink-%E5%9B%9B%E5%A4%A7%E5%9F%BA%E7%9F%B3/Snipaste_2023-02-27_20-13-37.png"></p>
<p>下图展示Checkpoint时整体流程，简易版本</p>
<p><img src="/2023/02/26/Flink-%E5%9B%9B%E5%A4%A7%E5%9F%BA%E7%9F%B3/Snipaste_2023-02-27_20-14-27.png"></p>
<ol>
<li>Flink的<code>JobManager</code>创建<code>CheckpointCoordinator</code>；</li>
<li>Coordinator向所有的<code>SourceOperator</code>发送Barrier栅栏(理解为执行Checkpoint的信号)；</li>
<li>SourceOperator接收到Barrier之后，暂停当前的操作(暂停的时间很短，因为后续的写快照是异步的)，并制作State快照, 然后将自己的快照保存到指定的介质中(如HDFS), 一切 ok之后向Coordinator汇报并将Barrier发送给下游的其他Operator；</li>
<li>其他的如TransformationOperator接收到Barrier，重复第2步，最后将Barrier发送给Sink；</li>
<li>Sink接收到Barrier之后重复第2步；</li>
<li>Coordinator接收到所有的Operator的执行ok的汇报结果，认为本次快照执行成功；</li>
</ol>
<p><img src="/2023/02/26/Flink-%E5%9B%9B%E5%A4%A7%E5%9F%BA%E7%9F%B3/Snipaste_2023-02-27_20-15-30.png"></p>
<p>栅栏对齐：下游subTask必须接收到上游的<strong>所有SubTask</strong>发送Barrier栅栏信号，才开始进行Checkpoint操作。</p>
<p><img src="/2023/02/26/Flink-%E5%9B%9B%E5%A4%A7%E5%9F%BA%E7%9F%B3/Snipaste_2023-02-27_20-16-24.png"></p>
<h3 id="Flink-Checkpoint之StateBackend"><a href="#Flink-Checkpoint之StateBackend" class="headerlink" title="Flink Checkpoint之StateBackend"></a>Flink Checkpoint之StateBackend</h3><p>​	</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># StateBackend（状态后端）：</span><br><span class="line">	1、State状态存储地方：内存Memory</span><br><span class="line">	</span><br><span class="line">	2、Checkpoint检查点存储地方：Fs文件系统或Memory</span><br></pre></td></tr></table></figure>



<p>Flink 1.13之前<strong>状态后端存储，三种方式：</strong>Memory（内存）、Fs（文件系统）和RocksDB（嵌入式数据库）**。</p>
<p><img src="/2023/02/26/Flink-%E5%9B%9B%E5%A4%A7%E5%9F%BA%E7%9F%B3/Snipaste_2023-02-27_20-18-31.png"></p>
<p>Checkpoint其实就<code>是Flink中某一时刻，所有的Operator的全局快照，那么快照应该要有一个地方进行存储</code>，而这个存储的地方叫做<strong>状态后端（StateBackend</strong>）。</p>
<p><img src="/2023/02/26/Flink-%E5%9B%9B%E5%A4%A7%E5%9F%BA%E7%9F%B3/Snipaste_2023-02-27_20-19-15.png"></p>
<blockquote>
<ul>
<li>1）、<code>MemoryStateBackend</code><ul>
<li>State存储：<strong>TaskManager</strong>内存中</li>
<li>Checkpoint存储：<strong>JobManager</strong>内存中</li>
</ul>
</li>
</ul>
</blockquote>
<p>[推荐使用的场景为：本地测试、几乎无状态的作业，比如 ETL、JobManager 不容易挂，或挂掉影响不大的情况。不推荐在生产场景使用。](</p>
<p><img src="/2023/02/26/Flink-%E5%9B%9B%E5%A4%A7%E5%9F%BA%E7%9F%B3/Snipaste_2023-02-27_20-19-51.png"></p>
<blockquote>
<ul>
<li>2）、<code>FsStateBackend</code><ul>
<li>State存储：&#x3D;&#x3D;TaskManager&#x3D;&#x3D;内存</li>
<li>Checkpoint存储：可靠外部存储文件系统，本地测试可以为LocalFS，&#x3D;&#x3D;测试生产HDFS&#x3D;&#x3D;</li>
</ul>
</li>
</ul>
</blockquote>
<p>[推荐使用的场景为：常规使用状态的作业，例如分钟级窗口聚合或 join、需要开启HA的作业](</p>
<p><img src="/2023/02/26/Flink-%E5%9B%9B%E5%A4%A7%E5%9F%BA%E7%9F%B3/Snipaste_2023-02-27_20-20-10.png"></p>
<p>当Checkpoint时存储到文件系统时，设置格式</p>
<p><img src="/2023/02/26/Flink-%E5%9B%9B%E5%A4%A7%E5%9F%BA%E7%9F%B3/Snipaste_2023-02-27_20-20-28.png"></p>
<blockquote>
<ul>
<li>3）、<code>RocksDBStateBackend</code><ul>
<li>RocksDB 是一个 嵌入式本地key&#x2F;value 内存数据库，和其他的 key&#x2F;value 一样，&#x3D;&#x3D;先将状态放到内存中，如果内存快满时，则写入到磁盘中&#x3D;&#x3D;。类似Redis内存数据库。</li>
<li>State存储：TaskManager内存数据库（&#x3D;&#x3D;RocksDB&#x3D;&#x3D;）</li>
<li>Checkpoint存储：外部文件系统，比如HDFS可靠文件系统中</li>
</ul>
</li>
</ul>
</blockquote>
<p>[推荐使用的场景为：超大状态的作业，例如天级窗口聚合、需要开启 HA 的作业、最好是对状态读写性能要求不高的作业。](</p>
<p><img src="/2023/02/26/Flink-%E5%9B%9B%E5%A4%A7%E5%9F%BA%E7%9F%B3/Snipaste_2023-02-27_20-20-57.png"></p>
<p>​	在Flink 1.13之前版本，<strong>状态Stage存储和Checkpoint检查点</strong>两个功能是混在一起的，即把<strong>状态存储和检查点的创建</strong>概念笼统的混在一起，导致初学者对此部分感觉很混乱，很难理解。</p>
<p><img src="/2023/02/26/Flink-%E5%9B%9B%E5%A4%A7%E5%9F%BA%E7%9F%B3/Snipaste_2023-02-27_20-21-40.png"></p>
<p>​	Flink 1.13 中将<code>状态State</code>和<code>检查点Checkpoint</code>两者区分开来。</p>
<p><img src="/2023/02/26/Flink-%E5%9B%9B%E5%A4%A7%E5%9F%BA%E7%9F%B3/Snipaste_2023-02-27_20-21-59.png"></p>
<p>Checkpoint存储支持2种方式：&#x3D;&#x3D;JobManager内存和FileSystem文件系统&#x3D;&#x3D;。</p>
<p><img src="/2023/02/26/Flink-%E5%9B%9B%E5%A4%A7%E5%9F%BA%E7%9F%B3/Snipaste_2023-02-27_20-22-20.png"></p>
<p>​	从<strong>Flink 1.13</strong>版本开始，社区重新设计了其公共状态后端类，以帮助用户更好地理解本地状态存储和检查点存储的分离。[此时StateBackend后端，分为2种情况：</p>
<p><img src="/2023/02/26/Flink-%E5%9B%9B%E5%A4%A7%E5%9F%BA%E7%9F%B3/Snipaste_2023-02-27_20-49-17.png"></p>
<p>Flink 1.13 中State和Checkpoint两个概念被拆开：</p>
<ul>
<li>State Backend 的概念变窄，只描述状态访问和存储；</li>
<li>Checkpoint storage，描述的是 Checkpoint 行为，如 Checkpoint 数据是发回给 JM 内存还是上传到远程。</li>
</ul>
<p><img src="/2023/02/26/Flink-%E5%9B%9B%E5%A4%A7%E5%9F%BA%E7%9F%B3/Snipaste_2023-02-27_20-50-19.png"></p>
<h3 id="Flink-Checkpoint之Savepoint-保存点"><a href="#Flink-Checkpoint之Savepoint-保存点" class="headerlink" title="Flink Checkpoint之Savepoint 保存点"></a>Flink Checkpoint之Savepoint 保存点</h3><p>Flink流式计算，提供<strong>Checkpoint机制，程序自动将State进行快速Snapshot，然后进行Checkpoint保存</strong>。此外，还支持用户可以&#x3D;&#x3D;手动进行Snapshot&#x3D;&#x3D;，保存State数据，称为：<code>SavePoint</code>保存点。</p>
<p><a target="_blank" rel="noopener" href="https://nightlies.apache.org/flink/flink-docs-release-1.13/docs/ops/state/savepoints/">https://nightlies.apache.org/flink/flink-docs-release-1.13/docs/ops/state/savepoints/</a></p>
<blockquote>
<p>[SavePoint保存点由&#x3D;&#x3D;用户&#x3D;&#x3D;手动创建、拥有和删除，它们的用例用于有计划的、手动的备份和恢复。](</p>
</blockquote>
<p><img src="/2023/02/26/Flink-%E5%9B%9B%E5%A4%A7%E5%9F%BA%E7%9F%B3/Snipaste_2023-02-27_20-54-05.png"></p>
<p><code>Savepoint</code>：保存点，类似于以前玩游戏的时候，遇到难关&#x2F;遇到boss，赶紧手动存个档，然后接着玩，如果失败了，赶紧从上次的存档中恢复，然后接着玩。</p>
<p><img src="/2023/02/26/Flink-%E5%9B%9B%E5%A4%A7%E5%9F%BA%E7%9F%B3/Snipaste_2023-02-27_20-54-33.png"></p>
<h4 id="保存点SavePoint和检查点Checkpoint区别："><a href="#保存点SavePoint和检查点Checkpoint区别：" class="headerlink" title="保存点SavePoint和检查点Checkpoint区别："></a>保存点SavePoint和检查点Checkpoint区别：</h4><p><img src="/2023/02/26/Flink-%E5%9B%9B%E5%A4%A7%E5%9F%BA%E7%9F%B3/Snipaste_2023-02-27_20-54-53.png"></p>

    </div>
    
    <div class="post-footer">
        <div>
            
            转载声明：
            商业转载请联系作者获得授权,非商业转载请注明出处 © <a href="" target="_blank">Snippet</a>
            
            
        </div>
        <div>
            
        </div>
    </div>
</article>
<div class="article-nav prev-next-wrap clearfix">
    
    <a href="/2023/03/01/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/" class="pre-post btn btn-default" title='面向对象编程'>
        <i class="fa fa-angle-left fa-fw"></i><span class="hidden-lg">上一篇</span>
        <span class="hidden-xs">
            面向对象编程</span>
    </a>
    
    
    <a href="/2023/02/24/Flink-Sql/" class="next-post btn btn-default" title='Flink_Sql'>
        <span class="hidden-lg">下一篇</span>
        <span class="hidden-xs">
            Flink_Sql</span><i class="fa fa-angle-right fa-fw"></i>
    </a>
    
</div>

<div id="comments">
    
    
<div class="utteranc">
  
  <script
    src='https://utteranc.es/client.js'
    repo='shenliyang/snippet-comment'
    issue-term='pathname'
    issue-number=''
    theme='github-light'
    label=''
    crossorigin='anonymous'
    async
  ></script>
</div>



</div>

                </main>
                
                    <aside id="article-toc" role="navigation" class="col-md-4">
    <div class="widget">
        <h3 class="title">
            Table of Contents
        </h3>
        
        <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Flink-%E5%9B%9B%E5%A4%A7%E5%9F%BA%E7%9F%B3%EF%BC%88Checkpoint%E3%80%81State%E3%80%81Time%E3%80%81Window%EF%BC%89"><span class="toc-text">Flink_四大基石（Checkpoint、State、Time、Window）</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-text">基本概念</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AA%97%E5%8F%A3-Window"><span class="toc-text">窗口 Window</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%B6%E9%97%B4-Time"><span class="toc-text">时间 Time</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%8A%B6%E6%80%81-State"><span class="toc-text">状态 State</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A3%80%E6%9F%A5%E7%82%B9-Checkpoint"><span class="toc-text">检查点 Checkpoint</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Flink-Window"><span class="toc-text">Flink Window</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Flink-Window-%E7%AA%97%E5%8F%A3%E7%9A%84%E7%BB%93%E6%9E%84"><span class="toc-text">Flink Window 窗口的结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Flink-Window%E4%B9%8BWindow-%E7%B1%BB%E5%9E%8B"><span class="toc-text">Flink Window之Window 类型</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Flink-Time"><span class="toc-text">Flink Time</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B9%B1%E5%BA%8F%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E4%B9%8BWatermark"><span class="toc-text">乱序数据处理之Watermark</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Watermark%E6%B0%B4%E4%BD%8D%E7%BA%BF%E5%AE%9A%E4%B9%89"><span class="toc-text">Watermark水位线定义</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Watermaek-%E5%A6%82%E4%BD%95%E8%AE%A1%E7%AE%97"><span class="toc-text">Watermaek 如何计算</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BB%B6%E8%BF%9F%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E4%B9%8BAllowed-Lateness"><span class="toc-text">延迟数据处理之Allowed Lateness</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-text">总结</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BB%B6%E8%BF%9F%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E4%B9%8BSide-Output"><span class="toc-text">延迟数据处理之Side Output</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%8A%B6%E6%80%81State"><span class="toc-text">状态State</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Flink-State-%E7%8A%B6%E6%80%81"><span class="toc-text">Flink State 状态</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Flink-State%E4%B9%8B%E7%8A%B6%E6%80%81%E5%8F%8A%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="toc-text">Flink State之状态及存储结构</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Flink-State%E4%B9%8B%E7%8A%B6%E6%80%81%E5%88%86%E7%B1%BB"><span class="toc-text">Flink State之状态分类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Keyed-State-%EF%BC%9A%E9%94%AE%E6%8E%A7%E7%8A%B6%E6%80%81"><span class="toc-text">Keyed State]()：键控状态</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Operator-State%EF%BC%9A%E7%AE%97%E5%AD%90%E7%8A%B6%E6%80%81"><span class="toc-text">Operator State：算子状态</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%A4%E7%A7%8D%E4%B8%8D%E5%90%8C%E7%B1%BB%E5%9E%8B%E7%8A%B6%E6%80%81%EF%BC%9A-x3D-x3D-Keyed-State%E4%B8%8EOperator-State-x3D-x3D-%EF%BC%8C%E6%AF%94%E8%BE%83%E5%A6%82%E4%B8%8B"><span class="toc-text">两种不同类型状态：&#x3D;&#x3D;Keyed State与Operator State&#x3D;&#x3D;，比较如下</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Flink-Checkpoint-%E6%A3%80%E6%9F%A5%E7%82%B9"><span class="toc-text">Flink Checkpoint 检查点</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Flink-Checkpoint%E4%B9%8B%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B"><span class="toc-text">Flink Checkpoint之执行流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Flink-Checkpoint%E4%B9%8BStateBackend"><span class="toc-text">Flink Checkpoint之StateBackend</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Flink-Checkpoint%E4%B9%8BSavepoint-%E4%BF%9D%E5%AD%98%E7%82%B9"><span class="toc-text">Flink Checkpoint之Savepoint 保存点</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BF%9D%E5%AD%98%E7%82%B9SavePoint%E5%92%8C%E6%A3%80%E6%9F%A5%E7%82%B9Checkpoint%E5%8C%BA%E5%88%AB%EF%BC%9A"><span class="toc-text">保存点SavePoint和检查点Checkpoint区别：</span></a></li></ol></li></ol></li></ol></li></ol>
        
    </div>
</aside>
                
            </div>
        </div>
    </section>
    <footer class="main-footer">
    <div class="container">
        <div class="row">
        </div>
    </div>
</footer>
<a id="back-to-top" class="icon-btn hide">
    <i class="fa fa-chevron-up"></i>
</a>
    <div class="copyright">
    <div class="container">
        <div class="row">
            <div class="col-sm-12">
                <div class="busuanzi">
    
</div>
            </div>
            <div class="col-sm-12">
                <span>Copyright &copy;
                    2017
                    
                </span> |
                <span>
                    Powered by <a href="//hexo.io" class="copyright-links" target="_blank" rel="nofollow">Hexo</a>
                </span> |
                <span>
                    Theme by <a href="//github.com/shenliyang/hexo-theme-snippet.git" class="copyright-links" target="_blank" rel="nofollow">Snippet</a>
                </span>
            </div>
        </div>
    </div>
</div>




<script src="/js/app.js?rev=@@hash.js"></script>

</body>
</html>